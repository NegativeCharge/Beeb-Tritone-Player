;Tritone beeper music engine - DATA FORMAT CORRECTED
;Original Z80 code by Shiru 03'2011, released as Public Domain
;1tracker version by Shiru 03'2018
;6502 engine port by utz 03'2024
;Ported to the BBC Micro by Negative Charge 03'2024
;Fixed: Correct interpretation of data format

; Constants
OSBYTE                  = $FFF4
OSWRCH                  = $FFEE
OSNEWL                  = $FFE7
SHEILABASE              = $FE00
SYSVIA_DDRA             = SHEILABASE + $43
SYSVIA_ORAS             = SHEILABASE + $4F
SYSVIA_REGB             = SHEILABASE + $40

DISPLAY_START           = $7c00
DEBUG                   = FALSE

; Zero Page
ORG     $60
GUARD   $90

.vars_start

.ch0_acc_lo         SKIP 1
.ch0_acc_hi         SKIP 1
.ch1_acc_lo         SKIP 1
.ch1_acc_hi         SKIP 1
.ch2_acc_lo         SKIP 1
.ch2_acc_hi         SKIP 1

.ch0_div_lo         SKIP 1
.ch0_div_hi         SKIP 1
.ch1_div_lo         SKIP 1
.ch1_div_hi         SKIP 1
.ch2_div_lo         SKIP 1
.ch2_div_hi         SKIP 1

.ch0_duty           SKIP 1
.ch1_duty           SKIP 1
.ch2_duty           SKIP 1

.loop_ptr           SKIP 2
.pattern_ptr        SKIP 2
.drum               SKIP 1
.row_length         SKIP 2

.vars_end

ORG     &1900
GUARD   DISPLAY_START

.start

INCLUDE "lib\os.s.6502" 

MACRO sound_write_slow
    sta     SYSVIA_ORAS
    lda     #%00000000
    sta     SYSVIA_REGB
    nop:nop:nop
    lda     #%00001000
    sta     SYSVIA_REGB
ENDMACRO

MACRO RESET_SOUND_CHIP
    lda     #%11111111
    sound_write_slow
    lda     #%11011111
    sound_write_slow
    lda     #%10111111
    sound_write_slow
    lda     #%10011111
    sound_write_slow
ENDMACRO

.init
    ldx     #1:ldy     #22
    jsr     moveTextCursor
    jsr     printString
    equs    "The Liberty Bell",0

    ldx     #1:ldy     #24
    jsr     moveTextCursor
    jsr     printString
    equs    "John Philip Sousa",0

    lda     #%11111111
    sta     SYSVIA_DDRA

    sei

    RESET_SOUND_CHIP

    lda     #%10000001
    sound_write_slow
    lda     #%00000000
    sound_write_slow
    
    lda     #%10100001
    sound_write_slow
    lda     #%00000000
    sound_write_slow
    
    lda     #%11000001
    sound_write_slow
    lda     #%00000000
    sound_write_slow

    lda     #%00000000
    sta     SYSVIA_REGB
    
    lda     #LO(music_data)
    ldx     #HI(music_data)

.play
    pha:txa:pha
    
    ; Clear ZP
    lda     #0
    ldx     #$0F
.clear_loop
    sta     $60,x
    dex
    bpl     clear_loop
    
    pla:sta pattern_ptr+1
    pla:sta pattern_ptr+0

    ldy     #0
    lda     (pattern_ptr),y:sta loop_ptr+0
    iny
    lda     (pattern_ptr),y:sta loop_ptr+1
    
    lda     pattern_ptr+0
    clc
    adc     #5
    sta     pattern_ptr+0
    bcc     play_loop
    inc     pattern_ptr+1

.play_loop
    ldy     #1
    lda     (pattern_ptr),y
    bne     no_loop
    
.return_loop
    lda     loop_ptr+0:sta pattern_ptr+0
    lda     loop_ptr+1:sta pattern_ptr+1
    jmp     play_loop

.no_loop
    iny
    lda     (pattern_ptr),y:sta row_length+0
    iny
    lda     (pattern_ptr),y:sta row_length+1
    jmp     row

.pattern_end
    cli
    RESET_SOUND_CHIP
    rts

.row
    ; Z80 logic:
    ; ld a,(hl) / inc hl / cp 2 / jr c,.ch0
    ; If < 2, go to ch0 (values 0 or 1)
    ; cp 128 / jr c,drumSound
    ; If 2-127, it's a drum
    ; cp 255 / jp z,nextPos
    ; If 255, pattern end
    ; Otherwise (128-254), fall through to ch0
    
    ldy     #0
    lda     (pattern_ptr),y
    iny                     ; Y=1 now
    
    cmp     #2
    bcc     ch0             ; If < 2 (0 or 1), go to ch0
    
    cmp     #128
    bcc     drum_cmd        ; If 2-127, it's a drum
    
    cmp     #255
    beq     pattern_end     ; If 255, end pattern
    
    ; Otherwise 128-254, fall through to ch0 processing
    ; This byte IS the ch0 data
    dey                     ; Y=0 again since we haven't consumed this byte yet

.ch0
    lda     (pattern_ptr),y
    iny                     ; Consume ch0 byte, Y now points to next
    
    cmp     #1
    beq     skip_ch0        ; Reuse previous ch0
    
    bne     ch0_check_note
    ; A = 0: clear channel
    sta     ch0_duty:sta ch0_div_lo:sta ch0_div_hi
    jmp     skip_ch0

.ch0_check_note
    ; A != 0 and A != 1, so it's note data
    tax
    and     #$0f
    sta     ch0_div_hi
    txa
    and     #$f0
    sta     ch0_duty
    lda     (pattern_ptr),y
    iny
    sta     ch0_div_lo
    jmp     skip_ch0

.drum_cmd
    ; A contains drum value (2-127)
    ; Store it and read next byte for ch0
    sta     drum
    jmp     ch0

.skip_ch0
    ; Y points to ch1 byte
    lda     (pattern_ptr),y
    iny
    
    cmp     #1
    beq     skip_ch1
    
    bne     ch1_check_note
    sta     ch1_duty:sta ch1_div_lo:sta ch1_div_hi
    jmp     skip_ch1

.ch1_check_note
    tax
    and     #$0f:sta ch1_div_hi
    txa
    and     #$f0:sta ch1_duty
    lda     (pattern_ptr),y
    iny
    sta     ch1_div_lo

.skip_ch1
    ; Y points to ch2 byte
    lda     (pattern_ptr),y
    iny
    
    cmp     #1
    beq     skip_ch2
    
    bne     ch2_check_note
    sta     ch2_duty:sta ch2_div_lo:sta ch2_div_hi
    jmp     skip_ch2

.ch2_check_note
    tax
    and     #$0f:sta ch2_div_hi
    txa
    and     #$f0:sta ch2_duty
    lda     (pattern_ptr),y
    iny
    sta     ch2_div_lo

.skip_ch2
    ; Y now contains the number of bytes consumed
    tya
    clc
    adc     pattern_ptr+0:sta pattern_ptr+0
    bcc     setup_play_loop
    inc     pattern_ptr+1

.setup_play_loop
    lda     row_length+0
    ora     row_length+1
    beq     row_finished
    
    ldx     row_length+0
    ldy     row_length+1

; ===================================================================
; INNER LOOP - Maximum speed
; ===================================================================
.play_note
    ; === CH0 === 
    lda     ch0_acc_lo
    clc
    adc     ch0_div_lo
    sta     ch0_acc_lo
    lda     ch0_acc_hi
    adc     ch0_div_hi
    sta     ch0_acc_hi
    cmp     ch0_duty
    lda     #$00
    sbc     #$00
    and     #$10
    sta     $00
    
    ; === CH1 ===
    lda     ch1_acc_lo
    clc
    adc     ch1_div_lo
    sta     ch1_acc_lo
    lda     ch1_acc_hi
    adc     ch1_div_hi
    sta     ch1_acc_hi
    cmp     ch1_duty
    lda     #$00
    sbc     #$00
    and     #$10
    ora     $00
    sta     $00
    
    ; === CH2 ===
    lda     ch2_acc_lo
    clc
    adc     ch2_div_lo
    sta     ch2_acc_lo
    lda     ch2_acc_hi
    adc     ch2_div_hi
    sta     ch2_acc_hi
    cmp     ch2_duty
    lda     #$00
    sbc     #$00
    and     #$10
    ora     $00
    
    ; === OUTPUT ===
    beq     silent
    lda     #$90
    equb    $2C
.silent
    lda     #$9F
    sta     SYSVIA_ORAS
    
    ; === COUNTER ===
    dex
    bne     play_note
    dey
    bne     play_note

.row_finished
    jmp     row

.s_print_hex
        pha
        lsr a:lsr a:lsr a:lsr a
        jsr     printNybble
        pla
        and     #&0f
.printNybble
        sed:clc
        adc     #&90
        adc     #&40
        cld
        jmp     OSWRCH

INCLUDE "tracks\liberty_bell_tritone.6502" 

.end

SAVE "MAIN",start,end,init

PRINT "-----------------------"
PRINT " 1-BIT TRITONE PLAYER  "
PRINT "-----------------------"
PRINT "CODE size       = ", ~end-start
PRINT "-----------------------"
PRINT "HIGH WATERMARK  = ", ~P%
PRINT "FREE            = ", ~start+end
PRINT "-----------------------"

PUTBASIC "loader.bas","LOADER"
PUTFILE  "BOOT","!BOOT",$ffff